---
sidebar_position: 1
title: Checkpoint Randomizer
description: A deep dive into the code changes for the Checkpoint Randomizer Mod
---

# Checkpoint Randomizer Mod - Code Review

<PostAuthors authors={["dallmeyer"]} authorNames={["barg034"]}/>

## Background

👋 Today I'm going to walk through the changes we made to build the Checkpoint Randomizer mod. To my knowledge, this was one of the earliest OpenGOAL mods, and as such there was a lot of trial and error to get things right. I'll do my best to describe the *process* of figuring out how things worked and what we needed to do, in addition to walking through the latest version of the code.

A little backstory to this mod - before OpenGOAL, there was actually a [predecessor that ran alongside the PCSX2 emulator](https://www.youtube.com/watch?v=jpYPk8eoDts), which would read from/write to PCSX2 memory, developed by [Ruh](https://www.youtube.com/@PunishedRuh). Around mid-2022 as OpenGOAL Jak 1 development was wrapping up, [Zed](https://github.com/Zedb0T) then ported the concept over to OpenGOAL. This is actually what sparked my interest in OpenGOAL modding, and how I met Zed 😅 he popped into my stream while I was trying out his original randomizer, we started talking about enhancements, and the rest is history. If you'd like to play this mod yourself, you can find it in the [Unofficial Mod Launcher](https://opengoal-unofficial-mods.github.io/).

![](./img/checkpoint_randomizer/gambler.png)

Initially, the intent of the mod was pretty straightforward - whenever you collect a Power Cell, it should warp you to a randomly selected checkpoint in the game. Over time, we've added quite a few enhancements and variations to this, such as:
- addressing miscellaneous softlocks and edge cases
- refactoring the random checkpoint logic to make it consistent based on an initial seed value
- letting the user change various options:
  - random seed vs set seed
  - randomizing by level vs by checkpoint
  - number of Power Cells collected before being warped
  - toggling warp when picking up Power Cells, Precursor Orbs, Scout Flies, Eco and/or dying
  - toggling a few additional custom checkpoints
- extending the pause menu to configure the above options, and persisting them to file

Unfortunately I don't have the cleanest *full* diff for this, because our Checkpoint Randomizer mod is bundled with some other challenge options (bonkless, pacifist, etc) and a bit of local multiplayer code. With that said [here is the full diff](https://github.com/dallmeyer/jak-project/compare/master...dallmeyer:jak-project:rando?w=1#files_bucket) of changes for this mod - I'll point out the specific pieces relating to the Checkpoint Randomizer as we go.

<iframe width="640" height="360" src="https://www.youtube.com/embed/MPPQ-9oYs3c?start=1013" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

## Main idea

### Checkpoint warping

First let's talk about the checkpoint system a bit. We'll start by looking at what the built-in debug menu offers, similar to how we explored what was possible with the camera in the [Blindfold Assist mod](./blindfold_assist#wherehow-is-the-camera-defined).

![](./img/checkpoint_randomizer/debug_continue.png)

Under `Game > Continue` you'll find the list of all checkpoints - your current checkpoint will be highlighted, and you can select any of them to warp to that checkpoint within your current game. This menu is incredibly useful in general for development purposes, and a great jumping off point for building this mod.

If we search for the `"Continue"` string in `goal_src/jak1/engine/debug/default-menu.gc`, we'll see that [here](https://github.com/open-goal/jak-project/blob/65f2146d736cf6cb4d8e0c09f12aceda18835e05/goal_src/jak1/engine/debug/default-menu.gc#L3536-L3538) it calls a `build-continue-menu` function, which looks like this:

```lisp
(defun build-continue-menu ((arg0 debug-menu) (arg1 game-info))
  (let ((s5-0 *level-load-list*))
    (while (not (null? s5-0))
      (let ((s4-0 (-> (the-as level-load-info (-> (the-as symbol (car s5-0)) value)) continues)))
        (while (not (null? s4-0))
          (let* ((v1-2 (the-as level-load-info (car s4-0)))
                 (a1-2 (new 'debug 'debug-menu-item-flag (the-as string (-> v1-2 name)) (-> v1-2 name) dm-current-continue))
                 )
            (debug-menu-append-item arg0 a1-2)
            )
          (set! s4-0 (cdr s4-0))
          )
        )
      (set! s5-0 (cdr s5-0))
      )
    )
  (the-as debug-menu-context arg0)
  )
```

Let's break this down - first it sets a local variable `s5-0` to `*level-load-list*` which is defined [here in `goal_src/jak1/engine/level/level-info.gc`](https://github.com/open-goal/jak-project/blob/b130b2eac27966c43f6816ee604a3a93a67e82fa/goal_src/jak1/engine/level/level-info.gc#L1943-L1970). `*level-load-list*` is technically of type [`pair`](../../reference/reader/#pair), but you can think of it like a [linked list](../../reference/reader/#list). Within this list, each element is an object of type [`level-load-info`](https://github.com/open-goal/jak-project/blob/b130b2eac27966c43f6816ee604a3a93a67e82fa/goal_src/jak1/engine/level/level-h.gc#L92-L127), defining a level within the game. Note that 'level' here refers to how the engine actually loads levels, and this doesn't always correspond one-to-one with the levels you see in the pause menu - for example, Spider Cave is actually represented as 3 distinct levels: `maincave`, `darkcave`, and `robocave`.

So for a list like this, what `s5-0` really represents is a reference to the first element in the list, whose `value` would be the `training` instance of `level-load-info` in our case. With this in mind, on the next line we see a `while` loop which runs until that reference becomes null - so you might reasonably guess that we'll be iterating through the list. Sure enough, a few lines down you'll see it reassigns `s5-0` to `(cdr s5-0)`, which advances us to the next element in the list. [`cdr`](../../reference/lib/#car-and-cdr) extracts the second element of the `pair`, which in the case of this list will either be another `pair` or null once we've reached the end of the list.

Within the level loop, we can see we have a new local variable `s4-0`, which is initially set to `(-> (car s5-0) value continues)` (type conversions removed for readability). [`car`](../../reference/lib/#car-and-cdr) extracts the first element of the `pair`, whose `value` in this case is the actual `level-load-info` object. Similar to how `*level-load-list*` is a list of `level-load-info` objects, each `level-load-info` object's [`continues`](https://github.com/open-goal/jak-project/blob/b130b2eac27966c43f6816ee604a3a93a67e82fa/goal_src/jak1/engine/level/level-h.gc#L110) field is a list of the `continue-point`s within that level. For example, we can see the `finalboss` level has 2 `continue-point`s:

```lisp
(define finalboss
  (new 'static 'level-load-info
    ...
    :continues '((new 'static 'continue-point
        :name "finalboss-start"
        :level 'finalboss
        :trans (new 'static 'vector :x 11548456.0 :y 2215872.0 :z -19409498.0 :w 1.0)
        :quat (new 'static 'quaternion :y 0.7325 :w 0.6807)
        :camera-trans (new 'static 'vector :x 11513311.0 :y 2234999.5 :z -19435708.0 :w 1.0)
        :camera-rot (new 'static 'array float 9 0.5883 0.0 -0.8085 0.1074 0.9911 0.0781 0.8014 -0.1328 0.5831)
        :load-commands '((special "citb-exit-plat-4" #t))
        :vis-nick 'fin
        :lev0 'finalboss
        :disp0 'display
        :lev1 'citadel
        :disp1 'special
        )
      (new 'static 'continue-point
        :name "finalboss-fight"
        :level 'finalboss
        :trans (new 'static 'vector :x 12288335.0 :y 1970461.9 :z -19848522.0 :w 1.0)
        :quat (new 'static 'quaternion :y -0.5359 :w -0.8442)
        :camera-trans (new 'static 'vector :x 12265366.0 :y 1984228.5 :z -19842574.0 :w 1.0)
        :camera-rot (new 'static 'array float 9 -0.243 0.0 -0.97 0.2594 0.9635 -0.065 0.9346 -0.2675 -0.2341)
        :load-commands '((special "citb-exit-plat-4" #t))
        :vis-nick 'fin
        :lev0 'finalboss
        :disp0 'display
        :lev1 'citadel
        :disp1 'special
        )
      )
    ...
    )
  )
```

From here the code uses a similar `while` loop to go through all the `continue-point`s in each level, and adds a new debug menu item for each one. I'll gloss over the details of the debug menu itself, but the important takeaway is that when one of these options is selected, it will run the `dm-current-continue` function and pass the name of the `continue-point` as an argument.

OK we're finally getting to where the magic happens! Within [`dm-current-continue`](https://github.com/open-goal/jak-project/blob/b130b2eac27966c43f6816ee604a3a93a67e82fa/goal_src/jak1/engine/debug/default-menu.gc#L301-L306), we see `(start 'play (get-continue-by-name *game-info* arg0))`. `arg0` here is the name of the `continue-point`, based on which option was selected in the debug menu. We can confirm this is the relevant code by connecting our REPL and running a sample such as `(start 'play (get-continue-by-name *game-info* "finalboss-fight"))`, which will send us to the final boss fight.

### Making it random

Alright so now we know how to warp to a particular `continue-point`, let's work on randomizing where we warp to. Let's assume you didn't know anything about RNG implementation in OpenGOAL - one way to figure out how RNG works is to pick something in the game that you know relies on RNG, and read through the related code. A nice isolated candidate for this is the fishing game in Forbidden Jungle, which uses RNG to determine the fish types and patterns.

If you search the codebase for "fishgame" you should eventually find yourself in `goal_src/jak1/levels/jungle/fisher.gc`, which contains the code for the fisherman and his fishing game. With some luck, you'll come across [the code where the fish are spawned](https://github.com/open-goal/jak-project/blob/65f2146d736cf6cb4d8e0c09f12aceda18835e05/goal_src/jak1/levels/jungle/fisher.gc#L1461-L1491), and in particular let's look at this `cond` branch:

```lisp
(cond
  ((rand-vu-percent? (-> self params powerup-percent))
    (if (and (>= (- (-> *display* base-frame-counter) (-> self ambient-big-one)) (seconds 30))
            (play-ambient (-> self ambient) "FIS-TA03" #t (-> self root-override trans))
            )
        (set! (-> self ambient-big-one) (-> *display* base-frame-counter))
        )
    'powerup
    )
  ((rand-vu-percent? (-> self params bad-percent))
    'bad
    )
  ((rand-vu-percent? (-> self params deadly-percent))
    'deadly
    )
  (else
    'normal
    )
  )
```

As you might guess from the name, `rand-vu-percent?` is one of the ways RNG can be introduced. Defined in [`goal_src/jak1/engine/math/math.gc`](https://github.com/open-goal/jak-project/blob/08ce65fd9bafa56f0d0017a9670112acc1019bb7/goal_src/jak1/engine/math/math.gc#L230-L233), this function will return `#t` with the probability that is provided as an argument. In this case, it's used to randomly determine whether a 5 pound fish (`'powerup`), an eel (`'bad`), or a 1 pound fish (`'normal`) will be spawned next, based on the probabilities set for that part of the fish game (`'deadly-percent` is always 0, so the `'deadly` branch is never hit 🤷‍♂️). 

`math.gc` actually contains a whole library of RNG functions that we can use in different scenarios, so now how can we use these to randomly choose a `continue-point` to warp to? Well if we had an array of 10 checkpoints, we could select an index by generating a random integer between 0 and 9 (inclusive) using [`rand-vu-int-count`](https://github.com/open-goal/jak-project/blob/08ce65fd9bafa56f0d0017a9670112acc1019bb7/goal_src/jak1/engine/math/math.gc#L230-L233). 

Unfortunately with the nested linked list design of `*level-load-info*` and the inner `continues` lists, it's tough to apply something like this directly. There are also a few test checkpoints that we'd want to exclude in the randomizer. So instead we can build a custom flat array of the checkpoints we want to use:

```lisp
(define *checkpoint-list* 
  (the-as (array string) 
    (new 'static 'boxed-array :type string :length 77 :allocated-length 77
      "game-start"
      "village1-hut"
      "village1-warp"
      "beach-start"
      ...
      "citadel-generator-end"
      "citadel-elevator"
      )
    )
  )
```

And then we're free to combine our checkpoint warp command with `rand-vu-int-count` to randomize where we warp to:

```lisp
(let ((checkpoint-name (-> *checkpoint-list* (rand-vu-int-count 77))))
  (start 'play (get-continue-by-name *game-info* checkpoint-name))
  )
```

### Triggering on Power Cell pickup

The last piece of the puzzle for the original mod is to trigger this randomized checkpoint warp whenever the player picks up a Power Cell. Internally these are known as `fuel-cell`s, and are [defined in `goal_src/jak1/engine/common-obs/collectables.gc`](https://github.com/open-goal/jak-project/blob/08ce65fd9bafa56f0d0017a9670112acc1019bb7/goal_src/jak1/engine/common-obs/collectables.gc#L1305-L1317). 

There are a few core steps in the process of collecting a Power Cell:

- [`fuel-cell` enters `pickup` state](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/common-obs/collectables.gc#L1525-L1965)
  - [`*target*` is sent `'get-pickup` event](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/common-obs/collectables.gc#L1659)
    - [`*target*` receives `'get-pickup` event](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/target/target-handler.gc#L42-L60)
      - [`(-> *target* fact-info-target)` is updated](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/game/game-info.gc#L616-L631)
        - [`*game-info*` (Power Cell internal counter) is updated](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/game/game-info.gc#L378-L399)
          - misc Power Cell stats are updated
          - related `entity-perm-status` and `game-task` is marked complete
  - [game auto-saves](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/common-obs/collectables.gc#L1667)
  - [Power Cell victory cutscene plays](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/common-obs/collectables.gc#L1668-L1673)

For this mod, we decided to [disable the victory cutscene](https://github.com/dallmeyer/jak-project/blob/76a46a233cad22c5d84f001329836d6a752f5aa4/goal_src/jak1/engine/common-obs/collectables.gc#L1700-L1707) and [execute the checkpoint warp here](https://github.com/dallmeyer/jak-project/blob/76a46a233cad22c5d84f001329836d6a752f5aa4/goal_src/jak1/engine/common-obs/collectables.gc#L1723-L1726), after the internal counter and related `entity-perm-status` and `game-task` are updated. In effect, the moment the victory cutscene would normally appear is when Jak is warped away.

It may be worth noting that if you use cheat/debug mode to give yourself Power Cells with L1 + R1 in the pause menu, this jumps directly to [sending `*target*` the `get-pickup` event](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/engine/ui/progress/progress.gc#L1883-L1892), without actually spawning any `fuel-cell`, auto-saving, or playing any victory cutscene. Because we added our checkpoint warping code to the `fuel-cell` code itself, "picking up Power Cells" this way does not trigger a warp.

## Softlocks & edge cases

### Citadel missing elevator

This was an interesting and important edge case we stumbled across: if you collected the Green Sage Power Cell and just so happened to warp back to the top of Citadel checkpoint, the elevator door would open but no elevator would appear (unless you died or de/respawned the elevator). What we realized was that the `(start 'play ...)` method of warping to a checkpoint would not reload any currently loaded levels or entities.

The [solution](https://github.com/dallmeyer/jak-project/blob/f3bdd9273531ea03e47c588862649fd9d7726a83/goal_src/jak1/engine/mods/checkpoint-randomizer.gc#L334-L343) we settled on was to instead warp by manually setting the checkpoint and then killing Jak 😬 which ensures the level is reloaded properly after the Power Cell has been collected. Our previous checkpoint warp approach would end up [setting the checkpoint here in `init-target`](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/target/logic-target.gc#L1932). If we look at the [definition for `set-continue!`](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/game/game-info.gc#L113), we see it should accept a `continue-point` or a string as an argument. Now we just need a proper way to kill Jak, and we again borrowed from the debug menu - this time looking at `Game > New Life` and copying the underlying [`(initialize! *game-info* 'die ...)` call](https://github.com/open-goal/jak-project/blob/a76f55853779118efe98a3115c7d78546ae40b6c/goal_src/jak1/engine/debug/default-menu.gc#L3391-L3395).

```lisp
(defun warpToCheckpoint ((checkpointName string))
  ;; warps to checkpoint, assuming it is already safe to use
  (format 0 "RANDOMIZER: ...warping to ~A~%" checkpointName)
  (set-continue! *game-info* checkpointName)

  ;; trigger death to warp to checkpoint
  ;; this ensures init functions for new level run (misty boat, citadel elevator)
  (initialize! *game-info* 'die (the-as game-save #f) (the-as string #f))
  (none)
  )
```

### Citadel softlock

One of the first softlocks we ran into was around Gol & Maia's Citadel, and the 2 things that initially prevent you from entering (or more important in this case, exiting):

1. There will be a large invisible wall in front of the Citadel entrance until you've collected the End of Lava Tube Power Cell from the Zoomer pad
2. The Citadel door won't open until you've pressed the Lava Tube warp gate button

With the checkpoint randomizer, it's entirely possible to collect all the Citadel Power Cells before unlocking these two things in Lava Tube. If you end up in this scenario and happen to get warped to Citadel again, there's no way to get out! To address this issue, we decided to automatically unlock the Citadel door and remove the invisible wall whenever you are in Lava Tube or Citadel.

To unlock the Citadel door, first we need to figure out its type so that we can identify the code that's involved. In the debug menu, there's a useful setting we can toggle to help with this: `Actor > Actor Mark > On`.

![](./img/checkpoint_randomizer/debug_actor_marks.png)

Now you can see the names (and infer the types) of all the actors around you! There's a useful "Distance Check" filter that you can get to from `Tools > Filters` in the top menu bar, so only the names of the closest actors would be shown.

![](./img/checkpoint_randomizer/ctib_iris_door_21.png)

So we see this is a `citb-iris-door`, which is [defined in `goal_src/jak1/levels/citadel/citadel-obs.gc`](https://github.com/open-goal/jak-project/blob/96761000397faea0480b6b9b8553bd7162187eba/goal_src/jak1/levels/citadel/citadel-obs.gc#L509-L515). Since no new fields or methods are defined for this type, the only thing this definition really tells us is that this is a child type of `eco-door`, which is [defined in `goal_src/jak1/engine/common-obs/baseplat.gc`](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/engine/common-obs/baseplat.gc#L150-L177).

This type has a field `locked` which sounds pretty suspicious - sure enough if we read through this file, we can see [`locked` is part of the check to decide if the door should go from `door-closed` to `door-opening`](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/engine/common-obs/baseplat.gc#L216-L223). We did some tests to try to unlock the door, looking it up by name and setting the field directly:


```lisp
(set! (-> (the citb-iris-door (process-by-ename "citb-iris-door-21")) locked) #f)
```

But the door remained locked. Looking back to the `door-closed` state, we found there's a [call](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/engine/common-obs/baseplat.gc#L215) to this method [`dummy-26`](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/engine/common-obs/baseplat.gc#L321-L330) right before the `locked` field gets checked. This method will update the `locked` field if there is a `state-actor` defined for the door, based on the actor's `entity-perm-status` - which in our case is the Lava Tube warp gate:

```lisp
gc> (-> (the citb-iris-door (process-by-ename "citb-iris-door-21")) state-actor)
44726468        #x2aa78c4              0.0000        #<entity-actor :name warp-gate-switch-12 @ #x2aa78c4>
```

Our attempt to unlock the Citadel door was reversed by the door re-locking itself immediately after, because the warp gate switch was not pressed. The [solution](https://github.com/dallmeyer/jak-project/blob/1589034851b300b6890137be4bc27b15439f24ef/goal_src/jak1/engine/mods/mods-common.gc#L60-L72) we settled on was to break the `state-actor` connection between the door and the switch:

```lisp
(defun unlock-citadel-door-no-cells ()
  ;; Unlock citadel door if the randomizer is on. Invis wall is removed elsewhere (racer.gc). Softlocks bad.
  (if (entity-by-name "citb-iris-door-21")
    ;; we break the link between the citadel door's state and the warp gate switch, 
    ;; and then manually open the door
    (let ((citb-iris-door-21 (the eco-door (-> (entity-by-name "citb-iris-door-21") extra process))))
      (set! (-> citb-iris-door-21 state-actor) #f)
      (set! (-> citb-iris-door-21 locked) #f) 
    )
  ))
```

As the comment there reminds us, we still have an invisible wall to dispose of. Unfortunately the debug tools (that I've tried) don't show anything for the invisible wall itself, but we knew from playing the game that it was somehow tied to the End of Lava Tube Power Cell. If we use the `Actor Marks` tool on that, it points us in the right direction again:

![](./img/checkpoint_randomizer/racer_36.png)

`racer` is defined in `goal_src/jak1/levels/racer_common/racer.gc`, and [at the top of the file](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/levels/racer_common/racer.gc#L8-L9) you might notice a couple of forward-declared functions: `blocking-plane-destroy` and `blocking-plane-spawn`. Turns out these are the functions used to spawn and despawn the invisible walls, a common feature of all the Zoomer (and Flutflut) pads throughout the game. In addition to limiting on-foot movement like here in Lava Tube, they are used to keep the Zoomer/Flutflut within their intended levels. Let's take a look at this `blocking-plane-spawn` that appears in the [init method for `racer`](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/levels/racer_common/racer.gc#L441-L450):

```lisp
(blocking-plane-spawn
  (the-as
    curve-control
    (if (or (and *target* (logtest? (-> *target* control root-prim prim-core action) (collide-action ca-9)))
            (= (-> obj condition) 3)
            )
        (-> obj path-racer)
        (-> obj path-target)
        )
    )
```

Each `racer` has 2 possible `path-controls` it will use for the invisible wall: `path-racer` and `path-target` (technically this is a `curve-control`, a child of `path-control`). When `racer` is initialized, there are a couple of conditions under which we will use `path-racer` (otherwise we will fall back to `path-target`):

- `(and *target* (logtest? (-> *target* control root-prim prim-core action) (collide-action ca-9)))` 
  - this is just the way of checking if you're already on the Zoomer 
  - you'll see a similar condition but with `(collide-action ca-14)` for [Flutflut's invisible walls](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/levels/flut_common/flutflut.gc#L370)
- `(= (-> obj condition) 3)`
  - `obj` here is the `racer` itself, and its [`condition` field is populated](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/levels/racer_common/racer.gc#L423) from the `'index` [res tag](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/engine/entity/res.gc#L8-L31_)
  - I won't pretend to understand what [all the different `racer` `condition`s represent](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/engine/entity/res.gc#L8-L31) (an enum sure would be nice), but the effect of `condition` 3 is that we'll [stay in `wait-for-start` state until the Power Cell has been collected](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/levels/racer_common/racer.gc#L164-L189)
  - TL;DR - this means the Power Cell hasn't been collected yet (at the time of `racer` initialization)

In the case of the `racer-36` at the end of Lava Tube, `path-target` is actually empty (it has 0 cverts compared to `path-racer` which has 2 cverts) which would result in no invisible wall being spawned:

```lisp
gc> (inspect (-> (the racer (process-by-ename "racer-36")) path-target))
[0023b6f4] curve-control
        ...
        num-cverts: 0
        ...
2340596        #x23b6f4              0.0000        #<curve-control @ #x23b6f4>

gc> (inspect (-> (the racer (process-by-ename "racer-36")) path-racer))
[0023b724] path-control
        ...
        num-cverts: 2
        ...
2340644        #x23b724              0.0000        #<path-control @ #x23b724>
```

So in the end, our solution is just to [force `path-target` to be used during `racer` initialization](https://github.com/dallmeyer/jak-project/blob/1589034851b300b6890137be4bc27b15439f24ef/goal_src/jak1/levels/racer_common/racer.gc#L442-L457):

```lisp
  (blocking-plane-spawn
    (the-as
      curve-control
      (if (enable-unlock-citadel-door-no-cells?)
        ;; in randomizer, don't spawn the invisible wall between lavatube/citadel
        (-> obj path-target)
        ;; original logic
        (if (or (and *target* (logtest? (-> *target* control root-prim prim-core action) (collide-action ca-9)))
                (= (-> obj condition) 3)
                )
            (-> obj path-racer)
            (-> obj path-target)
            )
      )
    )
  )
```

With these two changes, you are free to exit Citadel even if you've never stepped foot in Lava Tube 👍

### Misty softlock

A similar issue could leave you marooned on Misty Island. The fisherman's boat might appear at Misty, but it won't give the "PRESS O TO USE" prompt unless you've collected the fishing game Power Cell. So if you collected everything on Misty Island before doing that, you'll end up with way back to the mainland!

Debug menu to the rescue again - we can see that the boat on Misty Island is a [`fishermans-boat`](https://github.com/open-goal/jak-project/blob/66c680e8a348160de75c4fcda72c444c8378d9c8/goal_src/jak1/levels/village1/fishermans-boat.gc#L486-L530):

![](./img/checkpoint_randomizer/fishermans_boat_2.png)

There's a function `fishermans-boat-leave-dock?` in which we can see a reference to `(game-text-id press-to-use)` as well as a check `(cpad-pressed? 0 circle)`. This is where the game does some checks (e.g. is Jak close enough to the boat?) and conditionally shows the text prompt / listens for controller input to use the boat.

We can see one of the other checks in here is that you've completed the fishing game (or that you're in cheat mode and holding L3). The [simplest solution](https://github.com/dallmeyer/jak-project/blob/1589034851b300b6890137be4bc27b15439f24ef/goal_src/jak1/levels/village1/fishermans-boat.gc#L835-L842) we could come up with was just to extend this condition, and also let you use the boat whenever Misty Island is loaded. Since Misty Island is not loaded when you're still in Sandover Village, this does NOT let you use the boat back on the Sandover side, unless you meet one of the other conditions.

```lisp
(or 
  (task-complete? *game-info* (game-task jungle-fishgame)) 
  (and *cheat-mode* (cpad-hold? 0 l3)) 
  (or
    (= (-> *level* level 0 name) 'misty)
    (= (-> *level* level 1 name) 'misty)
    )
  )
```

## RNG Seeding

### Pre-generating checkpoint list

After ironing out these initial issues, we started thinking about speedruns of the checkpoint randomizer. One of the points that came up was around the integrity of runs and the checkpoints that were randomly chosen - how could we detect spliced runs or if the code was modified to give optimal checkpoints?

Our solution was to choose the checkpoints based on a particular seed for the RNG system, which would be displayed at the start of the run similar to the Speedrunner Mode display in vanilla OpenGOAL. This would ensure that anyone could replay a run using the same seed, and they ought to get the exact same checkpoints every time.

Unfortunately with our existing code, the checkpoints we got were still inconsistent even once we [set a specific seed for the `rand-vu` RNG system](https://github.com/open-goal/jak-project/blob/fb20bf34df7419f3279bd9170d06048625f2a1bb/goal_src/jak1/engine/math/math.gc#L172-L180) at the beginning of the run. We figured out this was because many other parts of the game were utilizing `rand-vu`, and cycling through a different number of random values depending on how you played. Since we were not calling `rand-vu` to choose the next checkpoint until the moment you picked up a Power Cell, this meant we'd end up hitting a different random value each time.

To get consistent values from a given seed, we needed to avoid any `rand-vu` calls in between the ones used for the checkpoint warps. We obviously couldn't just get rid of RNG throughout the game, so instead we chose to generate the entire checkpoint list at once - up front at the beginning of the run.

```lisp
(deftype rando-state (structure)
  (
    (next-idx int)
    (checkpoint-list (array string))
    )
  ...
  )

(define *rando-list-length* 1000)
(define *rando-state* (new 'global 'rando-state *rando-list-length*))

(defun generateCheckpointList ((seed float) (length int))
  ;; set the seed which will be used for generating checkpoint list
  (rand-vu-init seed)

  (dotimes (idx length)
    ;; append checkpoint
    (set! (-> *rando-state* checkpoint-list idx) (-> *checkpoint-list* (rand-vu-int-range 0 (-> *checkpoint-list* length))))
    )

  ;; reset initial index
  (set! (-> *rando-state* next-idx) 0)
  (none)
)
```

The original version stored the checkpoints in a linked list (like `*level-load-list*`) rather than an array, but otherwise the concept was the same. We initalize the RNG engine with the seed, and immediately generate the checkpoint list in a tight loop, thus guaranteeing we get a consistent list from any seed.

When the player collects a Power Cell, we just use the checkpoint at index `(-> *rando-state* next-idx)` for the warp, and then increment the `next-idx` field in preparation for the next warp. Just in case we somehow reach the end of the array, we can use the `mod` function to adjust the index and wrap back around to the beginning:

```lisp
(defun orchestrateCheckpointWarp ()
  (let ((checkpointName (-> *rando-state* checkpoint-list (-> *rando-state* next-idx))))
    ;; increment checkpoint list index for next time
    (set! 
        (-> *rando-state* next-idx)
        (mod (+ (-> *rando-state* next-idx) n) *rando-list-length*)
        )
    (warpToCheckpoint checkpointName)
    )
  )
```

### Restoring state after `gk` is closed

In the early versions of the randomizer, crashes were not uncommon. The game itself would auto-save when picking up the Power Cell, but the `rando-state` wasn't persisted. Since our code was only generating the checkpoint list when starting a new game, any crash meant you couldn't really continue your randomizer run (aside from manual intervention via the REPL).

With the new seeded approach we only needed to save two values in order to recreate the `rando-state`: the seed we used, and the latest `next-idx`. I'll go into more details about writing to/reading from files in [a later section](#randomizer-settings-file), but let's assume for now that we just need to update `*randomizer-settings*`. If we run into the case where the checkpoint list is not initialized (e.g. after a crash and reboot), we can regenerate the checkpoint list and advance through it to restore the previous state:

```lisp
(defun advanceCheckpointList ((n int))
  (set! 
    (-> *rando-state* next-idx)
    (mod (+ (-> *rando-state* next-idx) n) *rando-list-length*)
    )
  )

(defun orchestrateCheckpointWarp ((amount int))
  ;; in case of crash/closed window/etc, generate from last seed and advance checkpoints
  (when (null? (-> *rando-state* checkpoint-list 0))
    ;; generate checkpoint list from seed and advance idx
    (generateCheckpointList (-> *randomizer-settings* current-seed) *rando-list-length*)
    (advanceCheckpointList (-> *randomizer-settings* backup-next-idx))
    )
  ;; do checkpoint warp
  (let ((checkpointName (-> *rando-state* checkpoint-list (-> *rando-state* next-idx))))
    ;; increment checkpoint list index for next time
    (advanceCheckpointList 1)
    (set! (-> *randomizer-settings* backup-next-idx) (-> *rando-state* next-idx))
    (warpToCheckpoint checkpointName)
    )
  )
```

### Checkpoint predictability

After the refactoring to generate the checkpoint list up front, something interesting happened - speedrunner [Bintendo42](https://www.twitch.tv/bintendo42) started noticing patterns in the checkpoints she was getting, and eventually could often correctly predict what her next checkpoint would be!

Reviewing the code, I couldn't see any immediate issue with what we had added... until I recalled reading something in Discord about OpenGOAL not replicating the PS2 RNG exactly. On the PS2, there is a `Q` register which holds the quotient value from the most recent division operation, and this value is used as a source of randomness within the rand-vu engine.

![](./img/checkpoint_randomizer/water_q.png)

As water explains above (also mentioned in [this comment in `goal_src/jak1/engine/math/math.gc`](https://github.com/open-goal/jak-project/blob/fb20bf34df7419f3279bd9170d06048625f2a1bb/goal_src/jak1/engine/math/math.gc#L190-L194)), OpenGOAL omits this adjustment involving `Q`. So what's the impact of this on randomly generated values? Well I ran a test - I generated a random int between 0 and 99 (inclusive) 100,000 times and... the results were pretty evenly distributed across the 100 possible values 🤔

I ran another test, inspired by Bin's ability to predict her checkpoint based on the previous one. This time I kept track of the most recent 2 random values chosen, so that I could review the distribution across the 100x100 possible pairs of subsequent values. The results were pretty clear - there is a definite relationship between one randomly generated value and the next, even though all individual values are approximately equally likely to be chosen.

![](./img/checkpoint_randomizer/randvu_distribution.png)

Remember when we refactored the code to generate a consistent checkpoint list up front from the seed, and we wanted to avoid the miscellaneous `rand-vu` calls throughout the game? Well it turns out those calls were helping improve the randomness between checkpoint warps, and sidestepping them caused us to highlight this limitation in the OpenGOAL version of `rand-vu`.

This difference in `rand-vu` doesn't really cause any issues in casual gameplay, though speedrunners will know a couple of RNG manipulation tricks that can be performed on PS2 won't work the same way in OpenGOAL. However for the checkpoint randomizer, this was going to be a problem - we needed a way to consistently generate a list from a given seed, and to have the list feel truly random, without any patterns. 

I did some research into RNG and eventually found the [`java.util.Random` docs](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html), which clearly explain their implementation of "a linear congruential pseudorandom number generator as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.2.1".

Don't worry, no math lesson today - I went ahead and [ported this RNG engine over to OpenGOAL](https://github.com/open-goal/jak-project/blob/master/goal_src/jak1/pc/util/knuth-rand.gc) based on the Java docs. Once I had it working correctly, I ran the same sequential number test as I had previously run against the `rand-vu` engine, and the results were quite different:

![](./img/checkpoint_randomizer/knuth_distribution.png)

Happy with these results, I switched the checkpoint randomizer over to using this new `knuth-rand` engine instead of `rand-vu`.

## RNG Options

### Random seed vs set seed

### Randomizing by level

TODO: balancing gameplay; initial hack with repeated checkpoints

## Warp trigger variations

### Every X Power Cells

### Scout Flies

### Precursor Orbs

TODO: issues with crates, vents

### Eco

TODO: single vs vents

### Death

## Additional custom checkpoints

## Randomizer settings file

TODO: mirror pc-settings

## Pause menu randomizer options

TODO: on/off, slider

---

## Appendix

- [Using the OpenGOAL REPL](../repl)
- [OpenGOAL unofficial Mod Launcher](https://opengoal-unofficial-mods.github.io)
- [OpenGOAL Mod Base - Github](https://github.com/OpenGOAL-Unofficial-Mods/opengoal-mod-base)
- [OpenGOAL Randomizer Mod Pack - Github](https://github.com/OpenGOAL-Unofficial-Mods/opengoal-randomizer-mod-pack)
- [OpenGOAL Language Reference](../../reference)
  - [`if`](../../reference/lib/#if)
  - [`and`](../../reference/goos/#and)
  - [`cond`](../../reference/lib/#cond)
  - [`let`](../../reference/lib/#let)
  - [`let*`](../../reference/lib/#let-1)
  - [`+`](../../reference/lib/#-2)
  - [`-`](../../reference/lib/#-)
  - [`/`](../../reference/lib/#-4)
  - [`set!`](../../reference/goos/#set)
  - [`the-as`](../../reference/lib/#the-as)
  - [Processes and States](../../reference/process_and_state)
  - [Comments](../../reference/syntax/#comments)
